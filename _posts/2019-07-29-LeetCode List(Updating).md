LeetCode Question List

| Question                                                    | Type                                       | Description                                                  | Solution                                                     |
| ----------------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1.Two Sum                                                   | HashMap                                    | Return indeices of two numbers such that sum of them == target | Keep a HashMap and do a linear search, see if target - cur exists in Hashmap |
| 2. Add Two Numbers                                          | LinkedList                                 | Add Two LinkedLists                                          | Just traverse the linked list and add. Pay attention to different length of the numbers and carry on. |
| 3. Longest Substr wo repting chars                          | Index moving                               | As the title                                                 | When we see a repeating character, we update the starting index. We use hashMap to keep the info of where each char first appear and use that to calculate the result. |
| 4. Median of Two **Sorted** Arrs                            | Merge & sort                               | As the title                                                 | Just like a merge operation in merge sort. Pay attention to odd and even length of the array. |
| 5. Longest Palindromic Substr                               | Index moving                               | As the title                                                 | The question asks to return the palindrome. We need to find and keep the start and the length of the palindrome so we can rebuild it. Pay attention to multiple duplicate chars may appear in the center of the palindrome. Deal with them first and then update the index. |
| 6. ZigZag Conversion                                        | Implementation                             | Input: s = "PAYPALISHIRING", numRows = 4 Output: "PINALSIGYAHRPI" Explanation:  P     I    N A   L S  I G Y A   H R P     I (like a reverse N) | With extra storage:  Just loop through the string,  Keep track of the direction you're going and keep a storage of chars in a row. In the end merge all rows in the result.                   Without extra storage: Add every character in a row at the same time to the result. You can calculate the gap of index given the shape and the number of rows. |
| 8.String to Integer (atoi)                                  | Implementation                             | Basically ATOI, but you have a lot of constraints.           | Consider how to meet all the constraints in the simplest way when implementing the answer. Always check the requirement in the question. Ask yourself what else constrains or possibilities are implied by the question. |
| 11. Container With Most water                               | Two pointer(Greedy)                        | Find the largest area determined by two values in the array  | Moving the two index from the two ends, since the gap is always getting smaller, so we want the smaller value to be greater. We move the (left) pointer only when the right end is greater than the left end or otherwise (right). |
| 15. 3Sum                                                    | Moving index                               | a+b+c == 0                                                   | Sort the array, we loop the array, keep arr[i] as  the smallest number in the sequences and use two pointers l and r. When the sum is less or equal to target, we move l as long as the number at the point is the same as the one after. Same thing for the right side. We are taking advantage of the sorted sequence just like binary search. Pay attention to arr[i] larger than the target and duplicate arr[i]. |
| 16. 3Sum Closest                                            | Moving indexUs                             | Almost the same as 3 Sum                                     | We are looking for the closest sum right now. Change the way we're updating the answer, and every procedure is the same as that in 3 Sum. |
| 17. Letter Combinations of a Phone Number                   | DFS                                        | Phone key combination                                        | Keep a table of number to letters and then do DFS to find all combinations. |
| 18. 4 Sum                                                   | Moving index                               | as title                                                     | Very similar to 3 Sum. Add one more layer of iteration. Difference is that we now have more exceptional cases to consider when doing the loops. |
| 19. Remove Nth Node from end of list                        | Linked list                                | as title                                                     | Using two index, one pointing N elements ahead of the other, when the first one reach the end of the linkedlist, the other one is now pointing to the element to be removed.  Notice that you should init the two pointers to point to the node before the first node. |
| 20. Valid Parentheses                                       | Stack                                      | as title                                                     | When stack gets empty or stack top mismatches.               |
| 22. Generate Parentheses                                    | DFS                                        | as title                                                     | Keep a counter of left parentheses used and right parenthese to be used |
| 23. Merge K Sorted Lists                                    | Linked List                                | as title                                                     | Just like merge sort. This time, merging sorted lists. (Like a merge sort done in half actually) Pay attention to check null and pointed content when doing linked list problems. |
| 24. Swap Nodes in Pairs                                     | Linked List                                | Swap every two adjacent nodes and return its head.           | Linked list implementation problem. To keep the index, find our the length first. Then do swap and index shifting every time. |
| 25. Reverse Nodes in k-Group                                | Linked List                                | Reverse the numbers in group of K                            | You have to find the length first to do the iteration. Then do reverse in k iterations. |
| 26. Remove duplicate in sorted array                        | Implementation                             | Remove duplicate,  do the modification the same array and return the length afterwards. | Keep a index i of the modified array, when a  non-duplicate found, increase i and copy the value to index i. |
| 27. Remove element                                          | Almost the same as 26                      |                                                              |                                                              |
| 28. Implement strStr()                                      | Implementation                             | Find first Occurence of a string                             | ...                                                          |
| 31. Next Permutation(VIP)                                   | Implementation                             |                                                              | See Post (& Last Permutation)                                |
| 32. Longest Valid Parentheses(VIP)                          | Stack                                      |                                                              | See Post                                                     |
| 33. Search in Rotated Sorted Array                          | Binary Search                              |                                                              | Modified binary search. First Search for the turning point.  The do modified binary search based on adjusted index. |
| 34. Find First and Last Position of Element in Sorted Array | Binary Search                              | Exp. 1, 2, 3, 3, 4, 5.  target=3 retrun=[2,3]                | First time to find the start of the target sequence, just use normal lower bound technique. Then look for the lower bound of target + 1, which is the end of the target sequence. Be careful about updating l and r pointer when doing binary search and the exiting condition. |
| 35. Search Insert Position                                  | Binary Search                              |                                                              | Lower_bound                                                  |
| 36. Valid sudoku                                            | Binary Operation                           |                                                              | Use some arrays to store the status in each row, col, small block. The binary status represent which number is used in this area, updated using \| operation and when there is a number in this area and the & operation result is positive, return false. |
| 37. Sudoku solver                                           | DFS                                        |                                                              | Basic dfs and back-tracking. ONe technique is to preprocess the occupied info and gather all the points to be updated. |
| 39. Combination sum                                         | DFS                                        | Given a set of candidate numbers and a target number , find all unique combinations in where the sum(numbers) == target | Basic dfs and back-tracking, since all possible combinations are required by the problem. Since it's combination, you should track the last pos reached. |
| 40. Combination Sum2                                        | DFS                                        | This time there are duplicates in the array                  | Just skip the duplicates when doing dfs.                     |
| 41. First Missing Positive                                  | Bucket Sort                                | smallest missing positive integer.                           | The original array can be used as a bucket since the index is set. and place every number in the array into the right place, and the missing number is the number that is first not in the right place. |
| 43. Multiply Strings                                        | Big number multiply                        |                                                              | remember to remove leading zeros                             |
| 44. Wildcard Matching(VIP)                                  | String procecssing                         |                                                              | Do a post on this                                            |
| 45. Jump game 2                                             | Looks like DP, but can be solved by greedy | Your goal is to reach the last index in the minimum number of jumps. | Maintain the farthest point reachable right now and previous farthest reachable point, and update the steps and previous reachable point when reach the previous reachable point. The step count is the optimal (Since you are always trying to jump the farthest, farthest at each step  => optimal!!!).          See a dp-like question, ask yourself can I get an optimal solution just by making the greediest choice at each step? |
| 46. Permutations                                            | DFS                                        | All permutations                                             |                                                              |
| 47.                                                         | DFS                                        | With duplicates in array this time                           | With extra space: Using a visited array to store the visited information. Without extra space: Sort the array first, then keep two pointers and do swap between the two pointers and dfs, just don't do swaps when the two numbers are the same. |
| 48. Rotate image                                            | implementation                             | inplace rotation                                             | Do swap (swap mat\[i][j] and mat\[j][i]) then reverse        |
| 49. Group Anagrams                                          | Hashmap                                    | group all the anagrams                                       | Sort the current word and add to map, add the other words with same permutation to map then do retreival from map to form the final answer. |
| 50.pow(x, n)                                                | Implementation                             |                                                              | Just do fast pow, but be careful about some special cases as the range of inputs is integer |
| 51.N-Queens                                                 | DFS                                        | return board                                                 | classic back-track question                                  |
| 52.N-Queens 2                                               | DFS                                        | return number                                                |                                                              |
| 53. Spiral matrix(Practice)                                 | Implementation                             |                                                              | Moving in four directions and change range accordingly. Pay attention to the stopping conditions and range checking |
| 55. Jump Game                                               | Greedy                                     |                                                              | Similar solution to Jump Game 2. The only change is that you check whether maxJump is greater than the end of the array. |
| 56. Merge Intervals                                         | Sort & Implementation                      | Merge all overlapping intervals                              | Sort first according to the starting point. Then compare the starting point with end of the result sequence. |
| 57.Insert interval                                          |                                            | insert and merge                                             | Keep a new vector/ArrayList of the resulted intervals. Update the ends of the new interval based on the original intervals in the array. If the interval has no overlap with the new interval then just add it. |
| 54. Spiral Matrix2 (Practice)                               | Implementation                             |                                                              | Instead of traversing a given array, you should generate an array. Almost the same solution as the first one. |
| 60. Permutation Sequence(VIP)                               | (Obviously you can't use DFS here)         | The k th permutation                                         | Do a post on this question.                                  |
| 61. Rotate List                                             | Linked List                                | Rotate the linkedlist by k places                            | Inplace solution: Make the original linked list into a loop and then cut at kth place. Or you can create a list and move the last k elements to the new list and then merge. |
| 62. Unique Paths                                            | DP (Summing)                               | All unique paths moving accross a checker-board              | The base case is that the robot can move to every point in the graph with at least one unique path. The original dp expression would be f\[i][j] = f\[i][j - 1] + f\[i - 1][j]. However, we can determine that f\[i - 1][j] is the sum of f\[i - 1][0] to f\[i - 1][j - 1]. So we can remove the dimension of i by just suming f[j] = f[j - 1] for N times. Since each summing has included the sum from the last row. |
| 63. Unique Paths 2                                          | DP(Summing)                                | Obstacles placed                                             | When an obstacle appears, f[j] = 0, that's the only difference. |
| 64. Minimum Path Sum                                        | DP                                         | top left to bottom right                                     | f\[i][j] = min(f\[i - 1][j], f\[i][j - 1] ) + w\[i][j] Make sure that you init all grids except for those around the starting block to the MAX value. |
| 65. Valid Number                                            | Implementation                             | ...                                                          | Too complicated                                              |
| 66. Text Justification                                      | Implementation                             | ...                                                          | Just pay a lot of attention to details and have a clear understanding of what you're trying to write right now. |
| 71. Simplify Path                                           | Implementation with stack                  | Simplify an absolute path                                    | Path attention to the rules. Use stack to deal with \'..'    |
| 72. Edit Distance                                           | dp                                         | classical question                                           | f\[i][j] = f\[i - 1][j - 1] when chars equal, f\[i][j] = min(f\[i][j - 1], f\[i - 1][j - 1], f\[i - 1][j]) + 1. Make sure to init f\[i][0] and f\[0][i] to corresponding is since the base case is to delete every letter when the length is 0. |
| 73. Set Matrix Zeros                                        | Implementation                             | Given a *m* x *n* matrix, if an element is 0, set its entire row and column to 0. | Add some bool marks to check whether the row should be set zero. Store the information about which row is the last zero row. Do not update the last zero row to all zero at first, since we are using the last zero row to store the info about which column to clear. Then use info in the last zero row to update the column case. In this way, we can do the operation **in place**. |
| 74. Search a 2d matrix                                      | Binary Search                              | Write an efficient algorithm that searches for a value in an *m* x *n*matrix. | First you search which row the target belongs to, and then you. Then Search for the target in the row. |
| 75. Sort colors                                             | Implementation                             |                                                              | Write a merge sort or just can use bucket sort.              |
| 76. Minimum Window Substring                                | Sliding window like problem                | Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). | First record the count of each character in the target array. Then we keep two pointers and do updates on the count. The key is to keep a temp to find out how many letters we have not found in the source array. If we still have not found the required array, move end pointer forward (the longer, the more possible that it contains all the letters), then we try to minimize the length by moving start forward. |
| 77. Combinations                                            | DFS                                        | return all possible combinations of k numbers out of 1...n   | Just modified DFS from finding all combinations. Besides recoding the last position, you should also keep track of what numbers are used since we are not asked to use up all the numbers. |
| 78. Subsets                                                 | DFS                                        | Given a set of **distinct** integers, *nums*, return all possible subsets (the power set). | Sort the array and just push back every combination you visit. |
| 79. Word Search                                             | DFS                                        | Find a work in a 2d board                                    | Just do normal dfs, but one smart update method is to set the grid to some value that may not exist in the word so we don't need to keep an extra array of visited nodes. Remember to do border check. |
| 80. Remove duplicates from sorted array 2                   | implementation                             | remove duplicates in place, appear at most twice             | just keep a counter and do remove.                           |
| 81. Search in Rotated Sorted Array 2 (VIP)                  | Binary Search                              | With duplicates right now.                                   | Do a post                                                    |
| 83. Remove Duplicates from Sorted List                      | Linked List                                |                                                              | Compare current to the next of current. then update next if equals or shifts when not equals. |
| 82. Remove Duplicates from Sorted List2                     | Linked List                                | Remove any numbers with duplicates.                          | keep a pointer to the previous value and while the next value equals the duplicate value, remove it. |
| 84. Largest Rectangle in Histogram                          | Greedy                                     | Largest rectangle formed                                     | We are trying to find the values as large as possible, so we use a stack that keeps an increasing array of values looped in the array. Then we do the pop option when the stack is not empty and the current value is samller than the top of the stack. Then calculate the area. If stack is empty use the stack top height times i, else use the last highest value to time the gap. |
|                                                             |                                            |                                                              |                                                              |









